<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>奥多摩</title>
      <link href="/2022/11/02/%E5%A5%A5%E5%A4%9A%E6%91%A9/"/>
      <url>/2022/11/02/%E5%A5%A5%E5%A4%9A%E6%91%A9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><blockquote><p><strong>前言：</strong><br>本人初中以后基本就没写过作文，这是一篇小学生流水账。<br><strong>以下照片很多都不是我拍的，感谢兄弟们！！！</strong></p></blockquote><h2 id="奥多摩町"><a href="#奥多摩町" class="headerlink" title="奥多摩町"></a>奥多摩町</h2><p>虽然不是人生第一次露营，但来了日本以后还是第一次。</p><p>到东京也有半年了，活动范围也只在横滨，千叶；不计之前旅游去过的，最远的去过的地方也只是箱根。奥多摩町也在东京都内，位于多摩地域北西部，比起横滨和千叶还是要远一些。</p><p><a href="\source\images\image31.png" title="还挺远？" class="gallery-item"><img src="\source\images\image31.png" alt="还挺远？"></a></p><h2 id="出发"><a href="#出发" class="headerlink" title="出发"></a>出发</h2><h4 id="青梅市"><a href="#青梅市" class="headerlink" title="青梅市"></a>青梅市</h4><p>从新宿出发，乘坐中央线快速一个小时到达青梅，再从青梅乘坐青梅线半个小时到达奥多摩町。<br>由于到达青梅后下一班车到达还有一些时间，在青梅站附近走了走。远离东京一个小时的车程，伴随着一丝寒冷，惬意悠闲的生活气息也扑面而来。</p><p><a href="\source\icloud\IMG_6171.jpeg" title="青梅駅" class="gallery-item"><img src="\source\icloud\IMG_6171.jpeg" alt="青梅駅"></a><br><a href="\source\icloud\IMG_6183.jpeg" class="gallery-item"><img src="\source\icloud\IMG_6183.jpeg" alt=""></a></p><h4 id="奥多摩町-1"><a href="#奥多摩町-1" class="headerlink" title="奥多摩町"></a>奥多摩町</h4><p>下午两点多从新宿出发，一行人到达奥多摩的时候是五点半左右，这个时候天已经黑了。</p><p><a href="\source\icloud\IMG_6190.jpeg" title="到达" class="gallery-item"><img src="\source\icloud\IMG_6190.jpeg" alt="到达"></a></p><p><a href="\source\icloud\IMG_6199.jpeg" title="露营地小木屋旁的烧烤点" class="gallery-item"><img src="\source\icloud\IMG_6199.jpeg" alt="露营地小木屋旁的烧烤点"></a></p><p>从奥多摩町駅走五分钟左右，经过一座桥就到达了这次的露营地点。正八边形的亭子后面有工作台和水槽，在这里处理烧烤的食材。</p><h2 id="烧烤"><a href="#烧烤" class="headerlink" title="烧烤"></a>烧烤</h2><p><a href="\source\icloud\IMG_0494.JPG" class="gallery-item"><img src="\source\icloud\IMG_0494.JPG" alt=""></a></p><p><a href="\source\icloud\IMG_0495.JPG" class="gallery-item"><img src="\source\icloud\IMG_0495.JPG" alt=""></a></p><p><a href="\source\icloud\IMG_0496.JPG" class="gallery-item"><img src="\source\icloud\IMG_0496.JPG" alt=""></a></p><p><a href="\source\icloud\IMG_0493.JPG" title="乾杯！！！！" class="gallery-item"><img src="\source\icloud\IMG_0493.JPG" alt="乾杯！！！！"></a></p><h2 id="河边的篝火"><a href="#河边的篝火" class="headerlink" title="河边的篝火"></a>河边的篝火</h2><p><a href="\source\icloud\IMG_0509.JPG" class="gallery-item"><img src="\source\icloud\IMG_0509.JPG" alt=""></a></p><p><a href="\source\icloud\IMG_0506.JPG" class="gallery-item"><img src="\source\icloud\IMG_0506.JPG" alt=""></a></p><p><a href="\source\icloud\IMG_6209.gif" class="gallery-item"><img src="\source\icloud\IMG_6209.gif" alt=""></a></p><h2 id="星空"><a href="#星空" class="headerlink" title="星空"></a>星空</h2><p>图源：<a href="https://www.instagram.com/xiaohan_sa/">梅老板</a></p><p><a href="\source\icloud\IMG_6230.JPG" class="gallery-item"><img src="\source\icloud\IMG_6230.JPG" alt=""></a></p><p><a href="\source\icloud\IMG_6231.JPG" class="gallery-item"><img src="\source\icloud\IMG_6231.JPG" alt=""></a></p><h2 id="火炉与小木屋"><a href="#火炉与小木屋" class="headerlink" title="火炉与小木屋"></a>火炉与小木屋</h2><p>因为防疫<del>（迷惑）</del>政策，一个小木屋只能住五个人，睡前十个人聚在一间小木屋玩了会游戏。</p><p>（本人游戏黑洞，直男发言非常抱歉www，不过还是挺开心的。）</p><p>下午的新宿20度，凌晨的奥多摩只有5度左右。晚上睡觉的时候深切感受到了没穿秋裤的痛苦。</p><p><a href="\source\icloud\IMG_6232.JPG" class="gallery-item"><img src="\source\icloud\IMG_6232.JPG" alt=""></a></p><h2 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h2><p><a href="\source\icloud\IMG_0497.JPG" class="gallery-item"><img src="\source\icloud\IMG_0497.JPG" alt=""></a></p><p><a href="\source\icloud\IMG_0491.JPG" title="烤棉花糖" class="gallery-item"><img src="\source\icloud\IMG_0491.JPG" alt="烤棉花糖"></a></p><h2 id="风景"><a href="#风景" class="headerlink" title="风景"></a>风景</h2><p><a href="\source\icloud\IMG_0499.JPG" class="gallery-item"><img src="\source\icloud\IMG_0499.JPG" alt=""></a></p><p><a href="\source\icloud\IMG_0500.JPG" class="gallery-item"><img src="\source\icloud\IMG_0500.JPG" alt=""></a></p><p><a href="\source\icloud\IMG_0501.JPG" class="gallery-item"><img src="\source\icloud\IMG_0501.JPG" alt=""></a></p><p><a href="\source\icloud\IMG_0502.JPG" class="gallery-item"><img src="\source\icloud\IMG_0502.JPG" alt=""></a></p><p><a href="\source\icloud\IMG_0510.JPG" class="gallery-item"><img src="\source\icloud\IMG_0510.JPG" alt=""></a></p><p><a href="\source\icloud\IMG_0511.JPG" class="gallery-item"><img src="\source\icloud\IMG_0511.JPG" alt=""></a></p><h2 id="回程"><a href="#回程" class="headerlink" title="回程"></a>回程</h2><p>开始是结束的开始。</p><p>带着疲惫与不舍，匆忙赶上了回家的车。</p><p><a href="\source\icloud\IMG_6336.JPEG" class="gallery-item"><img src="\source\icloud\IMG_6336.JPEG" alt=""></a></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>来日本已经半年了。</p><p>一个人来到陌生的国家，说着陌生的语言，住在一个20平的公寓里。在快节奏的东京，独自面对着生活与学业的压力。决定人生走向的重要的考试不到两周，这次出门也意味着翘掉了关键的两节课。</p><p>可是，在边串着羊肉串边聊着天的时候；吃着烧烤举着啤酒干杯的时候；坐在篝火边看着星空的时候；围在小木屋里玩着游戏大笑的时候；甚至是摘下口罩，深吸一口林子里的空气的时候，一直埋藏在心里的焦虑和不安感好像能一扫而空。</p><p>从小到大一直接受着传统的中国式教育，文化课也好，竞赛也罢，在最好的学校进最好的班，用所有的精力拼尽全力去争第一。但是，人外有人，我并不认为我有这个天分与毅力，就算有，我也并不能为此感到快乐。所以，高二竞赛退役后，我受够了每天压迫的生活，我放弃了高考，放弃了憧憬的大学的优录政策，我想逃离这个没有终点的漩涡，我想在匆忙的生活中得到解脱，我决定来日本留学，我想去看看不一样的世界。</p><p>如果我之前努力学习，或者我现在努力学习，也许能爬到一个更高的位置。但是我太了解我自己了，面对天上的星星，我没有跳起来去摘的耐心和气力。我并不后悔。</p><p>当然，以上这些完全可以当成我给自己摆烂找的一个借口罢了，我想说的是，在学业与生活中，我更想找到一个适合自己的平衡点。</p><p>总而言之，我翘掉了课，来到了奥多摩。</p><p>我喜欢最近看到的一句话。</p><p>「あなたの衣を常に白くせよ。 あなたの頭に油を絶やすな。 」（「コヘレトの言葉９章８節」）</p><p>人，能知道自己什么时候死吗？正因为不知道，所以要永远身着白衣，头上永远不要缺少膏油。</p><p>悲观的说，这次旅行或许是我最后一次旅行；今天，或许是明天，可能就是我的最后一天，我永远都不知道。可是，这些回忆，这些照片，包括这拙劣的文字，就是我活着的印记。每当看到这些照片的时候，我能闻到羊肉串的香味，我能听到小木屋里的笑声，仿佛身处篝火边。短短两天的回忆就像奥多摩夜晚一颗闪亮的星星。</p><p>比起东京都繁华但冰冷的夜景，我更喜欢奥多摩璀璨而温暖的星空。</p><p>曾经的我，会在小红书或者空间里看到别人考的高分的时候焦虑，会在考试失败的时候怀疑和自卑，会后悔以前说错的话和做错的决定，会在无数个梦醒时分泪流满面。</p><p>而现在，我想我在奥多摩找到了答案。</p><p>最后的最后，就用和大家一起的合照作为这拙劣作文的一个句号吧。小河边的篝火升起的烟挡住了摄像头，却意外的营造出一种特别的氛围感。</p><p>非常感谢带我来的兄弟们，也希望大家能带着这样的笑容开开心心每一天！</p><p><a href="\source\icloud\IMG_6228.JPG" title="2022-10-29" class="gallery-item"><img src="\source\icloud\IMG_6228.JPG" alt="2022-10-29"></a></p><div align="right">  2022-11-3 04:03<br>  一个安静的夜晚</div></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      
        <tags>
            
            <tag> travel </tag>
            
            <tag> photos </tag>
            
            <tag> thinking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十月</title>
      <link href="/2022/10/18/%E5%8D%81%E6%9C%88/"/>
      <url>/2022/10/18/%E5%8D%81%E6%9C%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><table><tr><td><a href="\source\icloud\IMG_6038.jpeg" title="Aimer!" class="gallery-item"><img src="\source\icloud\IMG_6038.jpeg" alt="Aimer!"></a></td><td><a href="\source\icloud\IMG_6034.jpeg" title="yokohama" class="gallery-item"><img src="\source\icloud\IMG_6034.jpeg" alt="yokohama"></a></td></tr>  <tr><td><a href="\source\icloud\IMG_6048.jpeg" title="皇居周边" class="gallery-item"><img src="\source\icloud\IMG_6048.jpeg" alt="皇居周边"></a></td><td><a href="\source\icloud\IMG_6039.jpeg" class="gallery-item"><img src="\source\icloud\IMG_6039.jpeg"></a></td></tr><tr><td><a href="\source\icloud\IMG_6067.jpeg" title="明治神宫的婚礼" class="gallery-item"><img src="\source\icloud\IMG_6067.jpeg" alt="明治神宫的婚礼"></a></td><td><a href="\source\icloud\IMG_6071.jpeg" title="OW2的小号" class="gallery-item"><img src="\source\icloud\IMG_6071.jpeg" alt="OW2的小号"></a></td></tr><tr><td><a href="\source\icloud\IMG_6027.jpeg" class="gallery-item"><img src="\source\icloud\IMG_6027.jpeg"></a></td><td><a href="\source\icloud\IMG_5923.jpeg" title="新的外设!" class="gallery-item"><img src="\source\icloud\IMG_5923.jpeg" alt="新的外设!"></a></td></tr><tr><td><a href="\source\icloud\IMG_5963.jpeg" title="台风&暴雨" class="gallery-item"><img src="\source\icloud\IMG_5963.jpeg" alt="台风&暴雨"></a></td><td><a href="\source\icloud\IMG_6110.jpeg" class="gallery-item"><img src="\source\icloud\IMG_6110.jpeg"></a></td></tr></table></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>四月</title>
      <link href="/2022/10/18/%E5%9B%BE%E7%89%87%E6%B5%8B%E8%AF%95/"/>
      <url>/2022/10/18/%E5%9B%BE%E7%89%87%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><table><tr><td><a href="\source\images\image4.png" class="gallery-item"><img src="\source\images\image4.png"></a></td><td><a href="\source\images\image6.png" class="gallery-item"><img src="\source\images\image6.png"></a></td></tr>  <tr><td><a href="\source\images\image9.png" title="香港国际机场退税" class="gallery-item"><img src="\source\images\image9.png" alt="香港国际机场退税"></a></td><td><a href="\source\images\image11.png" title="刚好吃到海南鸡饭" class="gallery-item"><img src="\source\images\image11.png" alt="刚好吃到海南鸡饭"></a></td></tr><tr><td><a href="\source\images\image16.png" title="新宿华盛顿" class="gallery-item"><img src="\source\images\image16.png" alt="新宿华盛顿"></a></td><td><a href="\source\images\image26.png" class="gallery-item"><img src="\source\images\image26.png"></a></td></tr></table></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ABC267</title>
      <link href="/2022/09/04/ABC277/"/>
      <url>/2022/09/04/ABC277/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h2 id="Link"><a href="#Link" class="headerlink" title="Link"></a><a href="https://atcoder.jp/contests/abc267">Link</a></h2><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string ss[<span class="number">100</span>] = &#123;<span class="string">&quot;Monday&quot;</span>, <span class="string">&quot;Tuesday&quot;</span>, <span class="string">&quot;Wednesday&quot;</span>, <span class="string">&quot;Thursday&quot;</span>, <span class="string">&quot;Friday&quot;</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string a;</span><br><span class="line">    cin &gt;&gt; a;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) <span class="keyword">if</span> (a == ss[i]) t = i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="number">6</span> - t - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> x[<span class="number">15</span>], y[<span class="number">15</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//    freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    string a;</span><br><span class="line">    cin &gt;&gt; a;</span><br><span class="line">    <span class="keyword">if</span> (a[<span class="number">0</span>] == <span class="string">&#x27;1&#x27;</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;No&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        x[i] = (a[i - <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">    y[<span class="number">1</span>] += x[<span class="number">7</span>]; y[<span class="number">2</span>] += x[<span class="number">4</span>]; y[<span class="number">3</span>] += x[<span class="number">8</span>] + x[<span class="number">2</span>];</span><br><span class="line">    y[<span class="number">4</span>] += x[<span class="number">5</span>] + x[<span class="number">1</span>]; y[<span class="number">5</span>] += x[<span class="number">9</span>] + x[<span class="number">3</span>]; y[<span class="number">6</span>] += x[<span class="number">6</span>];</span><br><span class="line">    y[<span class="number">7</span>] += x[<span class="number">10</span>];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">6</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (y[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> LS = <span class="number">0</span>, RS = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> L = i - <span class="number">1</span>; L &gt;= <span class="number">1</span>; --L) &#123;</span><br><span class="line">                <span class="keyword">if</span> (y[L] != <span class="number">0</span>) LS = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> R = i + <span class="number">1</span>; R &lt;= <span class="number">7</span>; ++R) &#123;</span><br><span class="line">                <span class="keyword">if</span> (y[R] != <span class="number">0</span>) RS = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (LS &amp;&amp; RS) &#123; <span class="built_in">printf</span>(<span class="string">&quot;Yes&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><p>$L$から$R$までの一部とすると（$R=L+M-1$）、以下のような計算する</p><script type="math/tex; mode=display">\sum_{i=1}^{M}i\times A_i = \sum_{i=L}^{R} i\times A_i-(L-1)\times \sum_{i=L}^{R} A_i</script><p>INFに注意する。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line">ll b[maxn], c[maxn];</span><br><span class="line"><span class="keyword">const</span> ll INF = (<span class="number">1ll</span> &lt;&lt; <span class="number">60</span>);</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//    freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    <span class="keyword">int</span> N, M;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">    ll MAX = -INF; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);    </span><br><span class="line">        b[i] = b[i - <span class="number">1</span>] + (ll)i * a[i];</span><br><span class="line">        c[i] = c[i - <span class="number">1</span>] + a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N - M + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        ll TEMP = b[i + M - <span class="number">1</span>] - b[i - <span class="number">1</span>];</span><br><span class="line">        ll T2 = c[i + M - <span class="number">1</span>] - c[i - <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        MAX = <span class="built_in">max</span>(MAX, TEMP - (ll)(i - <span class="number">1</span>) * T2);</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, MAX);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><p>Cのような直接計算するのは無理。</p><p>動的計画法を行う。</p><p>時間計算量$O(nm)$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2010</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line">ll dp[maxn][maxn];</span><br><span class="line"><span class="keyword">const</span> ll INF = (<span class="number">1ll</span> &lt;&lt; <span class="number">60</span>);</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//    freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    <span class="keyword">int</span> N, M;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">    ll MAX = -INF; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= M; ++j) dp[<span class="number">0</span>][j] = -INF;    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= M; ++j) dp[i][j] = -INF;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= M; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; i) <span class="keyword">break</span>;</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + (ll)j * a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        MAX = <span class="built_in">max</span>(MAX, dp[i][M]);</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, MAX);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><p>ダイクストラ法のように、プライオリティーキューを使うことで $O((N+M)log(N+M))$ で解くことができる。</p><p>もう一つの方法は、答えを二分探索で行いう。スタックでコストはX以下の頂点を入れる。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;e[maxn];</span><br><span class="line">ll a[maxn], g[maxn];</span><br><span class="line"><span class="keyword">bool</span> del[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//    freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    <span class="keyword">int</span> N, M;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">        e[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">        e[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">        g[x] += a[y]; g[y] += a[x];</span><br><span class="line">    &#125;</span><br><span class="line">    priority_queue&lt;pair&lt;ll,<span class="keyword">int</span>&gt; &gt;q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(-g[i], i));</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        pair&lt;ll,<span class="keyword">int</span>&gt;QQ = q.<span class="built_in">top</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> x = QQ.second;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (del[x] || g[x] != -QQ.first) <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        del[x] = <span class="number">1</span>;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, -QQ.first);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; e[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = e[x][i]; <span class="keyword">if</span> (!del[t]) &#123;</span><br><span class="line">                g[t] -= a[x];</span><br><span class="line">                q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(-g[t], t));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//    printf(&quot;X = %d   ans = %d\n&quot; , x, ans);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><p>木の直径を利用する。</p><p>木の直径の両端の頂点を $L,R$とおく。<br>このとき、任意の頂点 $u$ に対し、$L,R$ のいずれかは $u$ から最も遠い点である。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;e[maxn];</span><br><span class="line"><span class="keyword">int</span> G[maxn][<span class="number">20</span>], H[maxn][<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> dep[maxn], n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> F[][<span class="number">20</span>])</span> </span>&#123;</span><br><span class="line">    F[x][<span class="number">0</span>] = fa;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; e[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = e[x][i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">17</span>; ++i) F[x][i] = F[F[x][i - <span class="number">1</span>]][i - <span class="number">1</span>];    </span><br><span class="line">        <span class="keyword">if</span> (u == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(u, x, F);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) dep[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FIND</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; e[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e[x][i] == fa) <span class="keyword">continue</span>;</span><br><span class="line">        dep[e[x][i]] = dep[x] + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">FIND</span>(e[x][i], x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mx = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (dep[i] &gt; mx) mx = dep[i], ans = i;</span><br><span class="line">    <span class="keyword">return</span> ans;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> dis, <span class="keyword">int</span> F[][<span class="number">20</span>])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; --i) <span class="keyword">if</span> ((dis &gt;&gt; i) &amp; <span class="number">1</span>) now = F[now][i];    </span><br><span class="line">    <span class="keyword">return</span> now == <span class="number">0</span> ? <span class="number">-1</span> : now;</span><br><span class="line">&#125;    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">        e[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">        e[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">FIND</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> L = <span class="built_in">get</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">FIND</span>(L, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> R = <span class="built_in">get</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(L, <span class="number">0</span>, G);</span><br><span class="line">    <span class="built_in">dfs</span>(R, <span class="number">0</span>, H);</span><br><span class="line">          </span><br><span class="line">    <span class="keyword">int</span> Q;</span><br><span class="line">    cin &gt;&gt; Q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Q; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);    </span><br><span class="line">        <span class="keyword">int</span> TA = <span class="built_in">solve</span>(x, y, G);</span><br><span class="line">        <span class="keyword">int</span> TB = <span class="built_in">solve</span>(x, y, H);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">max</span>(TA, TB));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E-1"><a href="#E-1" class="headerlink" title="E"></a>E</h2><h2 id="Ex"><a href="#Ex" class="headerlink" title="Ex"></a>Ex</h2></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Atcoder </tag>
            
            <tag> Contests </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC176</title>
      <link href="/2020/08/15/ABC176/"/>
      <url>/2020/08/15/ABC176/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="ABC176"><a href="#ABC176" class="headerlink" title="ABC176"></a><a href="https://atcoder.jp/contests/abc175">ABC176</a></h1><p>Rating:</p><p><a href="/images/ABC176/rating.PNG" class="gallery-item"><img src="/images/ABC176/rating.PNG" alt=""></a></p><p>正常发挥，甚至打的还挺好（因为F题比较难所以大家都是ABCDE），performance第一次上2000，虽然上分还是很缓慢。F题比赛上写出来的可能性不大。但是其实写前面几道题可以再快一点，不过根据我现在的水平，还是比较满意的。</p><p>C题WA了一次的原因是没看到输入的数据可能有负数。（其实把<code>x=read()</code>改成<code>x=abs(read())</code>就能过了），还是属于看题不认真（这个和英文水平低下好像没有关系）。</p><p>然后D题又想当然了，一个n个点n条边，每个点出度入度都为1的图不一定是一个环。可能是多个环。（详见APIO2018 铁人三项）。2018年搞不清白的东西现在还搞不清白。</p><p><a href="/images/ABC176/sticker.png" class="gallery-item"><img src="/images/ABC176/sticker.png" width="15%"></a></p><p>每个环单独做一次就好了，还好样例里面有两个环的情况不然可能就wa死在上面了。改代码花了点时间。</p><p>然后E题是个简单DP，好在昨天CF里面刚做了个简单DP，今天就知道有DP这个东西了。看题和写花了十几分钟。</p><p>F题是个比较神奇的题，属于那种数据范围比较小的连复杂度都想不好的题，不太会。</p><p><del>要是先开D题罚时可能会小一点。总感觉顺着做才是王道，感觉是因为水平不够不够自信才有此想法。</del></p><p>今天才发现ATC的计分机制是根据你最后一题的提交时间算的，所以只要会做，啥顺序都一样的。</p><p>等题解发了以后改F题。</p><p>UPD：鸽了</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Atcoder </tag>
            
            <tag> Contests </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CFEDU93</title>
      <link href="/2020/08/15/CFEDU93/"/>
      <url>/2020/08/15/CFEDU93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="EDU-93"><a href="#EDU-93" class="headerlink" title="EDU 93"></a><a href="https://codeforces.com/contest/1398">EDU 93</a></h1><p>Rating.png:</p><p><a href="/images/CFEDU93/rating.png" title="CFRoundEDU93" class="gallery-item"><img src="/images/CFEDU93/rating.png" alt="CFRoundEDU93"></a></p><p>正常发挥吧。毕竟就这水平。<br>AB没啥好说的，读题速度要是快点就好了。<br>C题不知道在想啥。想了一堆奇怪的东西（觉得区间是不交，是包含的，然后求每个数在的最小满足条件的区间就好了），然后发现这东西就是个错的（eg:03030）。莫名其妙花了好久，数组没清对还WA了一下。<br>D题做的挺慢的，想当然写个贪心然后WA。然后想了好久把才贪心叉掉。(eg: R:5 G:4 B:4,3)。就是两个较小的数相同的时候，选其中的一个是不对的。（R和G选了，B自己剩下两个没法配对）。然后改了个DP花了半个小时，虽然水的没办法，不过因为好久没写过DP了，勉强也能接受。<br>然后就只有半小时了，读了E和F。感觉比较麻烦，比赛时间是写不完了。但是应该都是可做题，这几天找个时间写一下。<br>发现最近学习效率都不太行，还是要高效一点。</p><p>Day2：发现E题看错了，以为是有负数收益的法术。<del>草，有SB。</del></p><p><a href="/images/CFEDU93/www.webp" class="gallery-item"><img src="/images/CFEDU93/www.webp" width="200px"/></a> </p><h1 id="E-Two-Types-of-Spells"><a href="#E-Two-Types-of-Spells" class="headerlink" title="E. Two Types of Spells"></a><a href="https://codeforces.com/contest/1398/problem/E">E. Two Types of Spells</a></h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>有两种法术，火焰法术造成一定伤害，雷电法术造成一定伤害还会使得下次伤害翻倍。</p><p>现在一个人啥也不会，每次学会一个法术或者忘掉之前的一个法术，问用现有的法术如何打出最大伤害（每个法术的收益大于0）。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>如果有$K$个雷电法术，那么翻倍的一定是目前会的伤害最大前$K$个。除非前$K$个全是雷电法术，那么放最前面的第一个雷电法术是不能翻倍的，这个时候还不如把一个最大的火焰法术放进去翻倍（也就是用最大的火焰法术换最小的雷电法术）。</p><p>支持插入和删除，要求维护：</p><ul><li>雷电法术的个数（$K$)</li><li>数组里面前$K$大的和</li><li>非前$K$大的数的和</li><li>第$K$大</li><li>最大的火焰法术</li></ul><p>知道这些东西以后，就可以判断是否都是雷电法术。如果不是都是，答案就是前$K$大×2+后面的和；</p><p>如果都是，答案就是前$K$大×2+后面的和-最小的雷电法术+最大的火焰法术。</p><p><strong>平衡树</strong></p><p>这些东西可以用数据结构去维护。平衡树维护子树和，树枝数组要离线和二分， 线段树维护子树大小和子树和然后二分。</p><p>这个是直接的做法。</p><p><strong>std::set</strong></p><p>基于每次的$K$最多加/减$1$，其实也有用set的维护方法。</p><p>分别用两个set表示前$K$大的数和剩下的数。</p><ul><li><p>如果要改变$K$的话，因为每次改一个，要么把第二个set的最大值丢到第一个set去，要么把第一个的丢到第二个里面去。</p></li><li><p>插入的时候，看插到哪个set里面去。</p></li><li><p>删除的时候，看是从哪个set里面删的。</p></li></ul><p>顺便维护每个set中所有元素的和。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x); <span class="keyword">return</span> x;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> A, B, C;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line">set&lt;<span class="keyword">int</span>&gt;F[<span class="number">2</span>];</span><br><span class="line">set&lt;<span class="keyword">int</span>&gt;Good, Bad;</span><br><span class="line">ll sumG, sumB;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fix</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Good.<span class="built_in">size</span>() &lt; F[<span class="number">1</span>].<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = *(--Bad.<span class="built_in">end</span>());</span><br><span class="line">        Bad.<span class="built_in">erase</span>(--Bad.<span class="built_in">end</span>());</span><br><span class="line">        sumB -= x;</span><br><span class="line">        Good.<span class="built_in">insert</span>(x);</span><br><span class="line">        sumG += x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (Good.<span class="built_in">size</span>() &gt; F[<span class="number">1</span>].<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = *Good.<span class="built_in">begin</span>();</span><br><span class="line">        Good.<span class="built_in">erase</span>(Good.<span class="built_in">begin</span>());</span><br><span class="line">        sumG -= x;</span><br><span class="line">        Bad.<span class="built_in">insert</span>(x);</span><br><span class="line">        sumB += x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Good.<span class="built_in">size</span>() &amp;&amp; Bad.<span class="built_in">size</span>() &amp;&amp; *(Good.<span class="built_in">begin</span>()) &lt; *(--Bad.<span class="built_in">end</span>())) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = *(Good.<span class="built_in">begin</span>());</span><br><span class="line">        <span class="keyword">int</span> p = *(--Bad.<span class="built_in">end</span>());</span><br><span class="line">        Good.<span class="built_in">erase</span>(Good.<span class="built_in">begin</span>()); Good.<span class="built_in">insert</span>(p);</span><br><span class="line">        sumG -= t; sumG += p;        </span><br><span class="line">        Bad.<span class="built_in">erase</span>(--Bad.<span class="built_in">end</span>()); Bad.<span class="built_in">insert</span>(t);</span><br><span class="line">        sumB -= p; sumB += t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        <span class="keyword">int</span> opt = <span class="built_in">read</span>(), Di = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">if</span> (Di &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            F[opt].<span class="built_in">insert</span>(Di);</span><br><span class="line">            Bad.<span class="built_in">insert</span>(Di); sumB += Di;</span><br><span class="line">            <span class="built_in">Fix</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Di &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            Di = -Di;</span><br><span class="line">            F[opt].<span class="built_in">erase</span>(F[opt].<span class="built_in">find</span>(Di));    </span><br><span class="line">            <span class="keyword">if</span> (Good.<span class="built_in">count</span>(Di)) Good.<span class="built_in">erase</span>(Good.<span class="built_in">find</span>(Di)), sumG -= Di;</span><br><span class="line">            <span class="keyword">if</span> (Bad.<span class="built_in">count</span>(Di)) Bad.<span class="built_in">erase</span>(Bad.<span class="built_in">find</span>(Di)), sumB -= Di;</span><br><span class="line">            <span class="built_in">Fix</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// calculate answer</span></span><br><span class="line">        <span class="keyword">if</span> (!Good.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            cout &lt;&lt; sumB &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!F[<span class="number">0</span>].<span class="built_in">size</span>() || *(--F[<span class="number">0</span>].<span class="built_in">end</span>()) &lt; *Good.<span class="built_in">begin</span>()) &#123; <span class="comment">// all lightning</span></span><br><span class="line">            <span class="keyword">int</span> t = *Good.<span class="built_in">begin</span>();</span><br><span class="line">            <span class="keyword">if</span> (Bad.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">int</span> p = *(--Bad.<span class="built_in">end</span>());</span><br><span class="line">                cout &lt;&lt; <span class="number">2ll</span> * sumG - t + p + sumB &lt;&lt; endl;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cout &lt;&lt; <span class="number">2ll</span> * sumG - t &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; sumG + sumG + sumB &lt;&lt; endl;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="F-Controversial-Rounds"><a href="#F-Controversial-Rounds" class="headerlink" title="F. Controversial Rounds"></a><a href="https://codeforces.com/contest/1398/problem/F">F. Controversial Rounds</a></h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>给出一个长为n的由01?三个东西构成的字符串。</p><p>?可以变成0或者1。</p><p>字符串中每有一个连续k个0或者k个1（长为k的连续段），答案就能加一，但是这些段都不能重合。</p><p>（题目把是连赢k次（对应字符串的1），或者连输k次（对应字符串的0）叫做一轮，问最多能有多少轮）</p><p>对于每个k从1到n，求最大答案。</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>比赛的时候感觉这题有点数学，想到了按照相同长度的去处理，复杂度nlogn，然后就不会做了= =</p><p>实际上除了复杂度以外啥都没想对。</p><p>这种题一起不好算，可以在之前的基础上考虑一个一个加，也就是按照顺序一个一个算，复杂度慢慢变小。</p><script type="math/tex; mode=display">n/1+n/2+n/3+n/4...n/n\approx nlogn</script><p>显然答案的和是$nlogn$级别的。</p><p>可以有一个$nlog^2n$的做法就是先计算二分$i$开始的最长的可能，然后排序，从大到小把每个位置加进一个<code>set</code>，每次计算的时候<code>lower_bound(i+size)</code>。</p><p>这样做其实多算了不必要的信息。</p><p>我们假设我们现在在$i$点，要求长度为$k$，暴力地比较了$[i,i+k-1],[i+1,i+k],[i+2,i+k+1]…$是不是有可能满足条件，一直找到了一个$j(j\geq i)$满足$[j,j+k-1]$符合条件。</p><p>根据这题的特殊性质：</p><p>那当我们算长度$k+1$的时候，之前算过的不满足条件的区间后面再加一个数字也不会满足条件。$[i,i+k],[i+1,i+k+1],[i+2,i+k+2]…$这些区间也不可能是答案</p><p>（因为$[i,i+k-1]$在长为$k$的时候就不是全$1$或者全$0$，$k+1$的话更不是了）</p><p>我们直接去看$[j,j+k]$。</p><p>用<code>nextQ[i]</code>表示如果<code>i</code>不行，下一次应该从哪个位置开始。</p><p>当长度为$k$算完后，<code>nexQ[i]</code>表示从i开始的最近的一个符合条件的区间的头。</p><p>这样就是$O(nlogn)$了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x); <span class="keyword">return</span> x;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"><span class="keyword">int</span> suma[maxn], sumb[maxn], nextQ[maxn];</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">itworks</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y = x + size - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> suma[y] - suma[x - <span class="number">1</span>] == (y - x + <span class="number">1</span>) || suma[y] - suma[x - <span class="number">1</span>] == <span class="number">0</span></span><br><span class="line">    || sumb[y] - sumb[x - <span class="number">1</span>] == (y - x + <span class="number">1</span>) || sumb[y] - sumb[x - <span class="number">1</span>] == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_next</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x + size - <span class="number">1</span> &gt; n) <span class="keyword">return</span> x; </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">itworks</span>(x, size)) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> nextQ[x] = <span class="built_in">find_next</span>(nextQ[x], size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    n = <span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) </span><br><span class="line">        suma[i] = suma[i - <span class="number">1</span>] + (s[i] == <span class="string">&#x27;1&#x27;</span> || s[i] == <span class="string">&#x27;?&#x27;</span>),</span><br><span class="line">        sumb[i] = sumb[i - <span class="number">1</span>] + (s[i] == <span class="string">&#x27;0&#x27;</span> || s[i] == <span class="string">&#x27;?&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) nextQ[i] = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> size = <span class="number">1</span>; size &lt;= n; ++size) &#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> position = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (position + size - <span class="number">1</span> &lt;= n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">itworks</span>(position, size)) position = position + size, ans++;</span><br><span class="line">            <span class="keyword">else</span> position = <span class="built_in">find_next</span>(position, size);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Contests </tag>
            
            <tag> Codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF664D2</title>
      <link href="/2020/08/14/CF664D2/"/>
      <url>/2020/08/14/CF664D2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="664-Div2"><a href="#664-Div2" class="headerlink" title="664 Div2"></a><a href="https://codeforces.com/contest/1395">664 Div2</a></h1><p>SB.jpg：</p><p><a href="/images/CF664D2/rating.png" title="CFRound664Div2" class="gallery-item"><img src="/images/CF664D2/rating.png" alt="CFRound664Div2"></a></p><p>A题瞎写WA一次；B题瞎写FST on Test45，最后发现自己的算法假的离谱，一个5×5的矩阵就能叉掉（就算如此还混过了pretest）；D题瞎写，计数的时候要把所用东西加起来，ans的初始值写-1（写0就行了），而且在莫名其妙的位置还爆了个int（两个1e5乘起来了）。</p><p>下次要注意细节了，不能再想当然。</p><h1 id="B-Boboniu-Plays-Chess"><a href="#B-Boboniu-Plays-Chess" class="headerlink" title="B. Boboniu Plays Chess"></a><a href="https://codeforces.com/contest/1395/problem/B">B. Boboniu Plays Chess</a></h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出一个矩阵，有一个棋子（走法同国际象棋中的车），给出矩阵的大小和棋子的初始位置，输出把每个位置走一遍，要求输出路径。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这题没啥好说的，看代码就行了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x); <span class="keyword">return</span> x;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>(), x = <span class="built_in">read</span>(), y = <span class="built_in">read</span>();</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (i != x) cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == y) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (t &amp; <span class="number">1</span>) <span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &gt;= <span class="number">1</span>; --j) cout &lt;&lt; j &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) cout &lt;&lt; j &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">        t++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="奇怪的东西"><a href="#奇怪的东西" class="headerlink" title="奇怪的东西"></a>奇怪的东西</h1><p>比赛的时候写的假算法是一直往一个方向走，然后把$4!$种方向的排列都试验一下。</p><p>然后愉快的FST on test45</p><p>错的原因是没用到这个题的性质，然后我发现有些情况按照我的想法是没有可行的方案的。</p><p>那么有了这么一个问题：</p><p>如果这个棋子每次只能走到相邻四联通的位置（上下左右），那么什么情况下是不存在走法的。</p><p><strong>首先给一个结论：只要是长和宽都是奇数的矩阵就不行。</strong></p><p>比说说给出3×3的矩阵，规定你起点是2 3，就不存在方案。</p><p>你可能觉得是因为起点在最外面一圈所以不行（因为这题规定起点不会在矩阵的最外圈）。</p><p>其实给出5×5的矩阵里面打叉这些位置作为起点都是不行的。</p><p><a href="/images/CF664D2/b2.PNG" class="gallery-item"><img src="/images/CF664D2/b2.PNG" alt=""></a></p><p>事实上这属于一个哈密顿路径问题，是一个图论问题。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>（英文资料都啃不动，看的全是中文的）</p><ul><li><p>一个写的很好的PPT：<a href="http://read.pudn.com/downloads151/ebook/655729/离散数学/8.2.pdf">PPT</a></p></li><li><p><a href="https://oi-wiki.org/graph/hamilton/">OIWIKI</a></p></li></ul><h3 id="哈密顿图-Hamilton-定义"><a href="#哈密顿图-Hamilton-定义" class="headerlink" title="哈密顿图(Hamilton)定义"></a>哈密顿图(Hamilton)定义</h3><ul><li><p>哈密顿通路(Hamilton path)：经过所有顶点的初级通路（经过所有点有且仅有一次）</p></li><li><p>哈密顿回路(Hamilton circuit/cycle)：经过所有顶点的初级回路</p></li><li><p>哈密顿图(Hamiltonian)：有哈密顿回路的图</p></li><li><p>半哈密顿图(semi- Hamiltonian)：有哈密顿通路的图</p></li></ul><h3 id="无向图中的必要条件"><a href="#无向图中的必要条件" class="headerlink" title="无向图中的必要条件"></a>无向图中的必要条件</h3><p>无向图<script type="math/tex">G=<V,E></script>是哈密顿图，则$V$的任意非空真子集$V_1$有</p><script type="math/tex; mode=display">p(G-V_1)\leq |V_1|</script><p>其中$p(G-V_1)$表示图G删去V1后的联通分支数。</p><p>如果是半哈密顿图则有</p><script type="math/tex; mode=display">p(G-V_1)\leq |V1| + 1</script><p>由于没学过太多的图论知识，这个东西好像不太好证明，但是可以考虑：如果是Hamiltonian/semi-Hamiltonian删除相邻的，剩下的联通数一点是最大的，但是不会大于|V1|。</p><p><a href="/images/CF664D2/b3.PNG" class="gallery-item"><img src="/images/CF664D2/b3.PNG" alt=""></a></p><h2 id="回到这题"><a href="#回到这题" class="headerlink" title="回到这题"></a>回到这题</h2><p>知道这个以后，可以发现，在长宽都是奇数的矩阵里面，只要删除$(n\times m -1)/2 $个点，那么矩阵中剩下$(n\times m - 1)/2 + 1$个点，但是为了规定起点，所以要新建一个点，只要这个点链接了被删除的点中的一个，那么就又多了一个联通分支，也就是说比删除的点的个数多了$2$个，这个不符合半哈密顿图的必要条件。</p><p><a href="/images/CF664D2/b.PNG" class="gallery-item"><img src="/images/CF664D2/b.PNG" alt=""></a></p><p>正因如此，类似这种（1，2）（2，1），在行列都为奇数的矩阵中，以行列和为奇数的点作为起点，不存在哈密顿路径。</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Contests </tag>
            
            <tag> Codeforces </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RSA算法</title>
      <link href="/2020/08/02/RSA/"/>
      <url>/2020/08/02/RSA/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="对称-非对称加密"><a href="#对称-非对称加密" class="headerlink" title="对称/非对称加密"></a>对称/非对称加密</h1><p>在1976年前，所有方法都是对称加密算法。</p><p>Alice想出一种可逆加密方法，把加密方法告诉Bob，Bob加密了消息把密码发给Alice，Alice根据加密方法解密。</p><p>要是别人截获了消息和加密方法，或者根据密码推测出加密方法，那么就能获得密码信息。</p><p>1976年，<a href="https://zh.wikipedia.org/wiki/迪菲-赫爾曼密鑰交換">Diffie–Hellman_key</a>提供了一种非堆成加密的思想。</p><p>Alice有两个密钥，公钥和私钥，把公钥告诉Bob，Bob加密了把消息把密码发给Alice，Alice用私钥解密。</p><p>非对称加密方法的好处是私钥是保存在电脑的，也就是无论别人窃取什么东西，没有私钥也无法解密。</p><p>RSA算法就是一种现在普遍使用的非对称加密算法。</p><h1 id="RSA算法"><a href="#RSA算法" class="headerlink" title="RSA算法"></a>RSA算法</h1><h2 id="构造过程"><a href="#构造过程" class="headerlink" title="构造过程"></a>构造过程</h2><p><a href="https://zh.wikipedia.org/zh-cn/RSA%E5%8A%A0%E5%AF%86%E6%BC%94%E7%AE%97%E6%B3%95">维基百科-RSA算法</a></p><ol><li><p>凭空变出两个质数$p,q$。</p></li><li><p>设$N=p\times q$</p></li><li><p>根据欧拉函数$r=\varphi(N)=(p-1)\times (q-1)$</p></li><li><p>凭空变出一个小于$r$的整数$e$使得$e$和$r$互质。</p></li><li><p>求$d$使得$ed \equiv 1 \pmod{r} $</p></li><li><p>销毁$p,q$，没有人知道$p,q$是多少。</p></li></ol><p>得出$(N,e)$是公钥，$(N,d)$是私钥。</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>Alice得到公钥和私钥，Alice把公钥告诉Bob，自己把私钥藏起来不告诉任何人。</p><p>Bob给Alice发消息。</p><h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><p>假设Bob的消息是$n$，密码是$c$，手上有公钥$(N,e)$</p><script type="math/tex; mode=display">c\equiv n^e \pmod{N}</script><p>Bob将加密后的$c$发给Alice</p><h3 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h3><p>Alice得到密码c，根据私钥$(N,d)$</p><script type="math/tex; mode=display">n\equiv c^d\pmod{N}</script><p>解密得到$n$</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><script type="math/tex; mode=display">c\equiv n^e \pmod{N}\\c^d\equiv n^{e\cdot d} \pmod{N}</script><p>因为$e\cdot d\equiv 1 \pmod{r}$，即$e\cdot d\equiv h\cdot r+1\pmod {N}$，其中$h$是自然数。</p><p>式子又可以写成</p><script type="math/tex; mode=display">c^d\equiv n^{h\cdot r+1} \pmod{N}\\c^d\equiv n^{h\cdot \varphi(N)+1}\pmod{N}\\c^d\equiv n\cdot n^{h\cdot \varphi(N)}\pmod{N}\\c^d\equiv n\cdot ({n^{\varphi(N)}})^h\pmod{N}\\</script><p>根据欧拉定理$a^\varphi(n)\equiv 1\pmod{n}$</p><script type="math/tex; mode=display">c^d\equiv n\times 1^h \pmod{N}\\c^d\equiv n \pmod{N}</script><h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><p>假设窃取者得到了$(N,e)$以及加密后的密码$c$，没有获得Alice的私钥$d$。鉴于多次剩余并不可求，目前唯一已知的（已公布的）方法就是将$N$分解质因数。</p><p>将$N$分解质因数得到$N=pq$，然后可以得到$r=\varphi(N)=(p-1)\times (q-1)$，根据$ed\equiv 1\pmod{r}$得到$d$。</p><p>所以目前认为只要$N$够大，黑客就没办法了。目前推荐的$N$的长度至少为2048位，不然可以很快分解。</p><p>已经证明量子计算机可以在多项式时间内进行因数分解。</p><p>如果量子计算机成型，RSA算法将被淘汰。</p><h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><h3 id="密钥生成"><a href="#密钥生成" class="headerlink" title="密钥生成"></a>密钥生成</h3><p>首先生成$N$，方法是用一个非常好的，而且没有被发表的方法（不会被窃取）随机生成一个看起来像质数的大数，然后用概率算法（类似Miller-Rabin）检验是否是质数。如果能通过测试，则进行精确的测试确保是一个质数。</p><p>$p$和$q$不能太靠近，而且$p-1$和$q-1$的因子不能太小。</p><p>$d$必须大。1990年有人证明$q&lt;p&lt;2q,d&lt;\frac{1}{3}N^{\frac{1}{4}}$，那么很好算出$d$。<br>以上证明我都不知道怎么证的，但是了解一下就好。</p><p>e=2永远不能用。</p><h3 id="算法速度"><a href="#算法速度" class="headerlink" title="算法速度"></a>算法速度</h3><p>由于要求很多以及计算过程比较复杂，RSA比较慢。实际运用（如TLS）是结合了非对称加密（如RSA）和一些对称加密（AES）</p><h3 id="密钥分配"><a href="#密钥分配" class="headerlink" title="密钥分配"></a>密钥分配</h3><p>假设Eve在Alice和Bob中间传话，把Alice告诉他的公钥独吞，告诉Bob自己的公钥，然后传递信息的时候先解密Bob的信息然后加密发给Alice，那么Alice和Bob甚至不知道有人窃取了信息。</p><p>现在人们通过一个<a href="https://zh.wikipedia.org/wiki/公開金鑰基礎建設">可信的第三者</a>来解决这一问题。即证书中心，一个可信的数字认证机构将用户的个人身份和公钥连接在一起，确定这个公钥就是Alice的而不是Eve窃取以后更改的。这个问题的前提是人们信赖第三方机构。</p><h3 id="攻击方法"><a href="#攻击方法" class="headerlink" title="攻击方法"></a>攻击方法</h3><p><strong>因数分解</strong></p><p>2009年 <a href="https://eprint.iacr.org/2010/006.pdf">RSA-768(768bit)被成功分解</a></p><p><strong>时间攻击</strong></p><p><a href="http://crypto.stanford.edu/~dabo/papers/ssl-timing.pdf">Paper</a></p><p>Even要是知道Alicze对特定密码的加密时间以及了解Alice的硬件设备，可能可以根据加密时取模的时间计算，因为1比0花的时间要多，可以推算出$d$。</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ATCF题集-1</title>
      <link href="/2020/08/01/ATCF-1/"/>
      <url>/2020/08/01/ATCF-1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="Multiplication-4"><a href="#Multiplication-4" class="headerlink" title="Multiplication 4"></a><a href="https://atcoder.jp/contests/abc173/tasks/abc173_e">Multiplication 4</a></h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给$n$个数字，选择$k$个数字乘积最大，输出答案</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>如果是偶数个数相乘，一定是最大的。按照正数和负数分开算的话有点麻烦，不如按组单独算。先把数组排序，可以证明<strong>答案是连续段（最多两段）</strong>，如果有左边的段，那一定是以最小值开头，有右边的话一定是以最大值结尾的。</p><p>证明如下：</p><p>首先，选择中间的数一定不如极值，因为无论怎样最大最小值中至少有一个比中间的数好。所以段一定是以最小值开头或者最大值结尾的。</p><p>如果两端都是正数/负数，显然合并成一段更优秀，这个时候就是一段。</p><p>那么一定是负数正数组成的段，考虑在中间选一个数（第三段）替换两段中的，同上，当然也不如极大/极小值。</p><p>所以可以假设现在是$[1\sim L]$和$[R \sim n]$，那么我们比较$a[L+1]\times a[L+2]$和$a[R]\times a[R+1]$的大小，决定是否$L+=2,R+=2$。</p><p>需要注意的是，如果相等的话要继续比较，因为并不单调。eg: 负负 负负 … 负正 正正，$a3\times a4=a7\times a8,a_1\times a_2 &lt; a_5\times a_6$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x); <span class="keyword">return</span> x;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, k, a[maxn];</span><br><span class="line"><span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(), k = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) a[i] = <span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = n - k + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r &amp;&amp; r &lt;= n - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1ll</span> * a[l] * a[l + <span class="number">1</span>] &gt;= <span class="number">1ll</span> * a[r] * a[r + <span class="number">1</span>]) l += <span class="number">2</span>, r += <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a[n] &lt; <span class="number">0</span> &amp;&amp; k &amp; <span class="number">1</span>) l = <span class="number">1</span>, r = n - k + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; l; ++i) ans = <span class="number">1ll</span> * ans * ((a[i] + mod) % mod) % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = r; i &lt;= n; ++i) ans = <span class="number">1ll</span> * ans * ((a[i] + mod) % mod) % mod;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Strivore"><a href="#Strivore" class="headerlink" title="Strivore"></a><a href="https://atcoder.jp/contests/abc171/tasks/abc171_f">Strivore</a></h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>给一个小写字母字符串$S$，随便在什么位置插入一个字符$K$次，最后能得到什么字符串，取模。</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>直接计算非常难算，因为会有很多重复的情况。我们可以考虑$S$作为一个子序列在新的字符串中第一次出现的每个字母的位置，这样计算的话不会有重复。</p><p>首先先固定每个字母作为子序列出现的位置。对于位置非$S$的位置$i$，如果在$S_n$之前，那么不能填下一个$S$的字符（因为填了的话S的子序列位置就是$i$了）；如果在$S_n$之后就可以随便填。那么就是$25^a\times 26^{K+N-a}$。</p><p>那么枚举$a$，那么确定$Sn$ 的新位置是$S_{a+n}$，剩下的$n-1$个数在$n+a-1$个位置里面选，乘上$\binom{n+a-1}{a-1}$就行了。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> fac[maxn], ifac[maxn];</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1ll</span> * x * y % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fpw</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = y; i; i &gt;&gt;= <span class="number">1</span>, x = <span class="built_in">mul</span>(x, x))</span><br><span class="line">        <span class="keyword">if</span> (i &amp; <span class="number">1</span>) r = <span class="built_in">mul</span>(r, x);</span><br><span class="line">    <span class="keyword">return</span> r; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inv</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">fpw</span>(x, mod - <span class="number">2</span>); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">mul</span>(x, <span class="built_in">mul</span>(y, z)); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">mul</span>(fac[n], ifac[m], ifac[n - m]); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x); <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    n = <span class="built_in">read</span>(); <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s); m = <span class="built_in">strlen</span>(s);</span><br><span class="line">    fac[<span class="number">0</span>] = ifac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + m; ++i) fac[i] = <span class="built_in">mul</span>(fac[i - <span class="number">1</span>], i), ifac[i] = <span class="built_in">mul</span>(ifac[i - <span class="number">1</span>], <span class="built_in">inv</span>(i)); </span><br><span class="line">    <span class="comment">// new length = m + n</span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        ans += <span class="built_in">mul</span>(<span class="built_in">mul</span>(<span class="built_in">C</span>(m + i - <span class="number">1</span>, i), <span class="built_in">fpw</span>(<span class="number">25</span>, i)), <span class="built_in">fpw</span>(<span class="number">26</span>, n - i));</span><br><span class="line">        ans %= mod;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl; </span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><h1 id="Camel-Train"><a href="#Camel-Train" class="headerlink" title="Camel Train"></a>Camel Train</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>有$n$个骆驼排队，第$i$个骆驼要是能排在前$K_i$个则能获得$L_i$都愉悦度，不在前$K_i$个获得$R_i$的愉悦度。如何排队才能获得最大愉悦度。</p><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p>首先可以先把$min(L_i,R_i)$加到答案上，这样的话把骆驼分为两类，如果$L_i&gt;R_i$，排在前$K_i$的获得$L_i-R_i$；如果$L_i&lt;R_i$，排在后$n-K_i$的获得$R_i-L_i$愉悦度。</p><p>可以发现这两种骆驼是可以分开算的，因为一个区间是$[1,L]$一个区间是$[R,n]$，如果占用了位置，可以把两个骆驼交换位置。</p><p>那么按照从大到小，贪心的计算。</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x); <span class="keyword">return</span> x;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">3e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"><span class="keyword">int</span> n, a[maxn], b[maxn];</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; a, pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.first == b.first ? a.second &gt; b.second : a.first &gt; b.first;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Solve</span><span class="params">(vector&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt;&amp;a)</span> </span>&#123;</span><br><span class="line">    set&lt;<span class="keyword">int</span>&gt;X;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) X.<span class="built_in">insert</span>(i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;u = a[i];</span><br><span class="line">        set&lt;<span class="keyword">int</span>&gt;::iterator It = X.<span class="built_in">upper_bound</span>(u.second);</span><br><span class="line">        <span class="keyword">if</span> (It != X.<span class="built_in">begin</span>()) &#123;</span><br><span class="line">            X.<span class="built_in">erase</span>(--It);</span><br><span class="line">            ans += u.first;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> T = <span class="built_in">read</span>(); </span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        vector&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt;L, R;</span><br><span class="line">        n = <span class="built_in">read</span>(); ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> k = <span class="built_in">read</span>(), l = <span class="built_in">read</span>(), r = <span class="built_in">read</span>();</span><br><span class="line">            ans += <span class="built_in">min</span>(l, r);</span><br><span class="line">            <span class="keyword">if</span> (l &gt; r) L.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(l - r, k));</span><br><span class="line">            <span class="keyword">else</span> R.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(r - l, n - k));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(L.<span class="built_in">begin</span>(), L.<span class="built_in">end</span>(), cmp);</span><br><span class="line">        <span class="built_in">sort</span>(R.<span class="built_in">begin</span>(), R.<span class="built_in">end</span>(), cmp);</span><br><span class="line">        <span class="built_in">Solve</span>(L); <span class="built_in">Solve</span>(R);</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="String-Transformation-1"><a href="#String-Transformation-1" class="headerlink" title="String Transformation 1"></a><a href="https://codeforces.com/contest/1384/problem/C">String Transformation 1</a></h1><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><p>给出字符串$A$和$B$，每次进行如下操作：</p><p>选择A中的几个位置，要求这几个位置是一样的字母。即选出$p[1\sim n]$满足$A[p_i]$是同一个字母$x$。然后把这些$x$全部替换成$y$，要求$y&gt;x$。</p><p>求把$A$变成$B$的最小操作次数。</p><h2 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h2><p>可以按照字母划分，根据字母$A$变成字母$B$，可以建立一个图出来。然后可以发现，一个大小为$n$的联通块只需要$n-1$次就能完成，用并查集计算即可。</p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> fa[maxn], n, a[maxn];</span><br><span class="line"><span class="keyword">char</span> s[maxn], t[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    <span class="keyword">return</span> x;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findf</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fa[x] == x ? x : fa[x] = <span class="built_in">findf</span>(fa[x]);    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="built_in">findf</span>(x), p = <span class="built_in">findf</span>(y);</span><br><span class="line">    fa[t] = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> T = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; ++i) fa[i] = i; </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>); <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, t + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">bool</span> fff = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (s[i] &gt; t[i]) &#123; fff = <span class="number">1</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span> (fff) &#123; cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; endl; <span class="keyword">continue</span>; &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = s[i] - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>, y = t[i] - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">findf</span>(x) == <span class="built_in">findf</span>(y)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">merge</span>(x, y); ans++; </span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h1 id="Cyclic-Shifts-Sorting"><a href="#Cyclic-Shifts-Sorting" class="headerlink" title="Cyclic Shifts Sorting"></a><a href="https://codeforces.com/contest/1374/problem/F">Cyclic Shifts Sorting</a></h1><h2 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h2><p>定义一次操作把$a[i],a[i+1],a[i+2]$的位置变成$a[i+2],a[i],a[i+1]$，求把一个数列排序的操作方法，最多能操作$n^2$次（不需要最小次数，可能无法排序），$n \leq 500$。</p><h2 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h2><p>可以从小到大对把第i个数放到第i个位置。把$i$向左移动两次需要一次操作，向左移动一次需要两次操作。这样操作以后，如果最后两个数没有排好就是不行。</p><p>对于每个数字不同的序列这个结论成立。</p><p>但是比如说 <code>1 2 3 3 6 4</code></p><p>可以交换相同的数字的位置，并且排序后面的<code>6 4</code>，这个结论就有问题了。</p><p>考虑到排序其实是消除逆序对，一次操作一定要么<strong>没改变</strong>，要么增加/减少了<strong>两个逆序对</strong>。</p><p>把<code>a b c</code>变成<code>c a b</code>，相对于其他的数位置关系没变，改变的是<code>c</code>和<code>a b</code>之间的位置关系。 </p><p>如果<code>a,b&lt;c</code>或者<code>c&lt;a,b</code>那么一次操作改变了两个逆序对，如果<code>c</code>在<code>ab</code>中间，那么没改变。</p><p>所以，如果有偶数个逆序对，一定可以排序。</p><p>如果是奇数个逆序对，而且如果没有相同的数，就不能排序。</p><p>但是，有相同的数的时候，可以把随便一对相同的数看成一个逆序对，构造出偶数个逆序对，就能排序了。</p><h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x); <span class="keyword">return</span> x;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn], c[maxn], d[maxn];</span><br><span class="line">pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;b[maxn];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Move</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> bef)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; x &lt;&lt; &#x27; &#x27; &lt;&lt; bef &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">while</span> (x &gt; bef + <span class="number">1</span>) &#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(x - <span class="number">2</span>);    </span><br><span class="line">        <span class="comment">// x - 2 x - 1 x</span></span><br><span class="line">        c[d[x]] -= <span class="number">2</span>;</span><br><span class="line">        c[d[x - <span class="number">1</span>]]++;</span><br><span class="line">        c[d[x - <span class="number">2</span>]]++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> t = d[x];</span><br><span class="line">        d[x] = d[x - <span class="number">1</span>]; d[x - <span class="number">1</span>] = d[x - <span class="number">2</span>]; d[x - <span class="number">2</span>] = t;</span><br><span class="line">        </span><br><span class="line">        x -= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x == bef + <span class="number">1</span>) &#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(bef);</span><br><span class="line">        ans.<span class="built_in">push_back</span>(bef);</span><br><span class="line">        </span><br><span class="line">        c[d[x]]--; c[d[x + <span class="number">1</span>]]--;</span><br><span class="line">        c[d[x - <span class="number">1</span>]] += <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> t = d[x];</span><br><span class="line">        d[x] = d[x + <span class="number">1</span>]; d[x + <span class="number">1</span>] = d[x - <span class="number">1</span>]; d[x - <span class="number">1</span>] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Solve</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">Move</span>(c[b[i].second], i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">read</span>(); ans.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) a[i] = <span class="built_in">read</span>(), b[i] = <span class="built_in">make_pair</span>(a[i], i), c[i] = i, d[i] = i;</span><br><span class="line">        <span class="built_in">sort</span>(b + <span class="number">1</span>, b + <span class="number">1</span> + n);</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>, sm = <span class="number">0</span>, b1 = <span class="number">0</span>, b2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i] &gt; a[j]) &#123;</span><br><span class="line">                    cnt ++; b1 = i; b2 = j;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (a[i] == a[j]) sm = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!sm &amp;&amp; cnt &amp; <span class="number">1</span>) &#123; <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>); <span class="keyword">continue</span>; &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (b[i].first == b[i - <span class="number">1</span>].first) &#123;</span><br><span class="line">                        <span class="built_in">swap</span>(b[i].second, b[i - <span class="number">1</span>].second);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="built_in">Solve</span>(n);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans.<span class="built_in">size</span>());</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ans[i]);    </span><br><span class="line">            &#125; <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      <categories>
          
          <category> Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Atcoder </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>莫比乌斯反演</title>
      <link href="/2018/12/01/Mobius_inversion/"/>
      <url>/2018/12/01/Mobius_inversion/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="Something-useful"><a href="#Something-useful" class="headerlink" title="Something useful"></a>Something useful</h1><ol start='' ><li>$\lfloor \frac{n}{i}\rfloor$只有$O(\sqrt n)$种取值</li><li>对于$i$，$\left\lfloor\frac{n}{\left\lfloor\frac{n}{i}\right\rfloor}\right\rfloor$是与$i$被$n$除并下取整取值相同的一段区间的右端点</li><li>$\left\lfloor\frac{n}{ab}\right\rfloor=\left\lfloor\frac{\left\lfloor\frac{n}{a}\right\rfloor}{b}\right\rfloor=\left\lfloor\frac{\left\lfloor\frac{n}{b}\right\rfloor}{a}\right\rfloor$</li></ol><h1 id="Mobius-function"><a href="#Mobius-function" class="headerlink" title="Möbius function"></a>Möbius function</h1><p>用$\mu$表示莫比乌斯函数。$$n=p_1^{q_1}p_2^{q_2}...p_k^{qk}\\\mu(n)=\begin{cases} 1 & (x=1) &\\ 0 & (\max_{i}^{n} p_i>1) \\ (-1)^{k} & \text{otherwise}\end{cases}$$</p><p>一个有用的性质$$\sum_{d|n}\mu(d)=[n=1]$$证明：考虑$d|n$相当于在$n$的因子中选择若干个，然后把这些因子组成的数的$\mu$加起来，如果有一个数的次数大于$1$，$\mu = 0$对答案没有贡献，所以这个$\mu$值只与选择的质因子的个数的奇偶性有关，也就是说只考虑每个质因子是否选择。$$\text{if}~~~n =1~~~\mu(1)=1\\\text{else}~~~n=p_1^{q_1}p_2^{q_2}...p_k^{qk}\\\sum_{d|n}\mu(d)=\binom{k}{0}-\binom{k}{1}+\binom{k}{2}-\binom{k}{3}...+(-1)^k\binom{k}{k}\\\sum_{d|n}\mu(d)=\sum_{i=0}^{k}(-1)^i\binom{k}{i}\\\because (1+x)^{k}=\sum_{i=0}^{k}\binom{k}{i}x^i\\\therefore x=-1\\\sum_{d|n}\mu(d)=\sum_{i=0}^{k}(-1)^i\binom{k}{i}=(1+(-1))^k = 0\\$$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">Sieve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxn; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!flag[i]) &#123;</span><br><span class="line">            prime[++prime[<span class="number">0</span>]] = i;</span><br><span class="line">            mu[i] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= prime[<span class="number">0</span>] &amp;&amp; i * prime[j] &lt; maxn; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = i * prime[j]; flag[v] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> mu[v] = -mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Dirichlet-product"><a href="#Dirichlet-product" class="headerlink" title="Dirichlet product"></a>Dirichlet product</h1><p>记$f,g$为数论函数，定义$$h=f*g \rightarrow h(n)=\sum_{d|n, d > 0}f(d)\times g(\frac{n}{d})\\$$狄利克雷卷积满足<strong>交换律</strong>，<strong>结合律</strong>和<strong>分配率</strong>。</p><h3 id="常见的积性函数"><a href="#常见的积性函数" class="headerlink" title="常见的积性函数:"></a>常见的积性函数:</h3><ol start='' ><li>$\mu$，莫比乌斯函数。</li><li>$\varphi$ ，欧拉函数。</li><li>$d$ ，约数个数。$d(n)$表示 $n$ 的约数的个数。</li><li>$\sigma$ ，约数和函数。$\sigma(n)$表示 $n$ 的各个约数之和。</li></ol><h3 id="常见的完全积性函数"><a href="#常见的完全积性函数" class="headerlink" title="常见的完全积性函数:"></a>常见的完全积性函数:</h3><ol start='5' ><li>$\epsilon$ ，元函数。 $\epsilon(x)=[x=1]$</li><li>$I$ ，恒等函数。 $I(n)=1$</li><li>$id$ ，单位函数。$id(n)=n$</li></ol><h3 id="常用的狄利克雷卷积"><a href="#常用的狄利克雷卷积" class="headerlink" title="常用的狄利克雷卷积:"></a>常用的狄利克雷卷积:</h3><script type="math/tex; mode=display">\begin{cases}I * \mu = \epsilon\\\mu * id = \varphi\\I * id = \sigma\\I * I = d\\I * \varphi = id\end{cases}</script><h1 id="Mobius-inversion-formula"><a href="#Mobius-inversion-formula" class="headerlink" title="Möbius inversion formula"></a>Möbius inversion formula</h1><p>对于数论函数$f, g$$$\begin{aligned}f(n)&=\sum_{d|n}g(d)\\f &= g * I\\f * \mu &= g * I * \mu\\f * \mu &= g * (I * \mu)\\f * \mu &=g * \epsilon\\f * \mu &= g\\\end{aligned}$$然后得到了$$g(n)=\sum_{d|n}f(d)\times \mu(\frac{n}{d})$$对于另一个式子$$\begin{aligned}f(n)&=\sum_{n|d}^{d\leq L}g(d)\\g(n)&=\sum_{n|d}^{d\leq L}f(d)\times \mu(\frac{d}{n})\end{aligned}$$</p><h2 id="Tricks"><a href="#Tricks" class="headerlink" title="Tricks"></a>Tricks</h2><ol start='' ><li><p>$\sum_{i=1}^{n}\sum_{j=1}^{m}[(i,j)=d]$</p><p>设$f(d)$表示集合中$(i,j)=d$的倍数的数的$(i,j)$的个数，$g(d)$表示$(i,j)=d$的数的个数（我们要求的答案是$g(d)$）。$$\begin{aligned}f(d)&=\lfloor{\frac{n}{d}}\rfloor\lfloor\frac{m}{d}\rfloor\\&=\sum_{d|t}^{\min(n,m)}g(t)\\g(d)&=\sum_{d|t}^{\min(n,m)}f(t) \mu(\frac{t}{d})\\&=\sum_{d|t}^{\min(n,m)}\lfloor{\frac{n}{t}}\rfloor\lfloor\frac{m}{t}\rfloor\mu(\frac{t}{d})\end{aligned}$$<strong>小技巧:</strong></p><p>记$\sigma(n)$为$n$的约数个数，因为$I * id = \sigma$</p></li></ol><p><p>$$\sigma(nm)=\sum_{i|n}^{n}\sum_{j|m}^{m}[(i,j)=1]$$</p></p><ol start='2' ><li><p>$\sum_{i}^{n}\sum_{j=1}^{m}[(i,j)\in \text{Prime}]$$$\sum_{p\in Prime}\sum_{p|t}^{\min(n,m)}\lfloor{\frac{n}{t}}\rfloor\lfloor\frac{m}{t}\rfloor\mu(\frac{t}{p})$$对于所有$t=p(Prime) \times \frac{t}{p}$，预处理$\text{pre[t]}$。$$\begin{aligned}\text{pre[t]}&=\sum_{p|t}\mu(\frac{t}{p})\\ans&=\sum_{t}^{\min(n,m)}\text{pre[t]}\lfloor{\frac{n}{t}}\rfloor\lfloor\frac{m}{t}\rfloor\end{aligned}$$</p><p>预处理$\text{pre}$可以枚举质数然后用调和级数，同时也可以在线筛的时候算。</p><p>考虑$\text{prime[j]} \not| i$，加入$\text{prime[j]}$会让$\mu\to -u$，之前的$f[i]$变为$-f[i]$，贡献为$\mu[i]$，$f[i \times prime[j]]=-f[i]+mu[i]$</p><p>如果$\text{prime[j]}| i$，加入$\text{prime[j]}$让除了$i$的所有因子上有一个$prime[j]^2$，此时$f[i\times prime[j]]=mu[i]$</p></li><li><p>$\sum_{i=1}^{n}\sum_{j=1}^{m}(i,j)^k$$$\sum_{p}\sum_{p|t}^{\min(n,m)}\lfloor{\frac{n}{t}}\rfloor\lfloor\frac{m}{t}\rfloor\mu(\frac{t}{p})p^k\\\sum_{p}p^k\sum_{p|t}^{\min(n,m)}\mu(\frac{t}{p})\lfloor{\frac{n}{t}}\rfloor\lfloor\frac{m}{t}\rfloor$$同上，我们可以预处理$\text{pre[t]}$$$\text{pre[t]}=\sum_{d|t}d^k\mu(\frac{t}{d})$$由于$\mu$是积性函数，$d^k$也是积性函数，所以$pre[t]$是积性函数</p><p>对于$\text{pre}[p^x], p \in \text{Prime}$，由于$\mu(p^2)$以上都是0，对答案无贡献。$$\begin{aligned}pre(p^x)&=(p^{x}\cdot\mu(1) + p^{k(x-1)}\cdot \mu(p)) & p \in \text{Prime}\\\end{aligned}$$一般地$$\begin{aligned}pre(n)&= \sum_{d \mid n}d^k\mu(\frac T d)\\&= \prod_{p_i} pre(p_i^{x_i})\\&= \prod_{p_i} (p_i^{x_i}\cdot\mu(1) + p_i^{k(x_i-1)}\cdot \mu(p_i))\\&= \prod_{p_i} p_i^{k(x_i-1)}(p_i^k-1)\end{aligned}$$</p></li></ol><h1 id="Du’s-Sieve"><a href="#Du’s-Sieve" class="headerlink" title="Du’s Sieve"></a>Du’s Sieve</h1><ul><li>$\mu$前缀和</li></ul><p><p>$$\begin{aligned}\sum\limits_{i=1}^n\sum\limits_{d|i}\mu(d)&=1\\\sum\limits_{i=1}^n\sum\limits_{j=1}^{\left\lfloor\frac{n}{i}\right\rfloor}\mu(j)&=1\\\sum_{i=1}^{n}\mu(i)&=1-\sum_{i=2}^{n}\sum_{j=1}^{\left\lfloor\frac{n}{i}\right\rfloor}\mu(j)\end{aligned}$$   考虑右边式子，由于是${\left\lfloor\frac{n}{i}\right\rfloor}$，所以只有$\sqrt n$种不同的取值，$\sum_{j=1}^{\left\lfloor\frac{n}{i}\right\rfloor}\mu(j)$是一个前缀和的性质，于是可以递归求，求的过程中用hash表实现记忆化防止复杂度退化。</p></p><p><p>   时间复杂度</p><script type="math/tex; mode=display">\begin{aligned} &\sum_{i=1}^{\sqrt n}O(\sqrt i) + \sum_{i=1}^{n}O(\sqrt \frac{n}{i}) \\ &=O(\int_{1}^{n}\sqrt{\frac{n}{x}}dx)\\ &=O(n^{\frac{3}{4}}) \end{aligned}</script><p>   注意到$n$比较小的时候可以线性筛出来。 </p><script type="math/tex; mode=display">O\left(B+\sum\limits_{i=1}^{\frac nB}\sqrt{\frac ni}\right)=O\left(B+\frac n{\sqrt{B}}\right)</script><p>   根据均值不等式当$B=n^{\frac{2}{3}}$有最低复杂度$O(n^{\frac{2}{3}})$&lt;/p&gt;</p><ul><li>$\varphi$前缀和$$\begin{aligned}\because \sum_{d|n}\varphi(d)&=n\\\therefore \sum_{i=1}^{n}\sum_{d|i}\varphi(d)&=\sum_{i=1}^{n}\\&=\frac{n(n+1)}{2}\\\sum_{i=1}^{n}\varphi(i)&=\frac{n(n-1)}{2}-\sum_{i=2}^{n}\sum_{j=1}^{\left\lfloor\frac{n}{i}\right\rfloor}\varphi(j)\end{aligned}$$做法和复杂度同上。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sieveMu</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; Limit) <span class="keyword">return</span> mu[n];</span><br><span class="line">    <span class="keyword">if</span> (map_mu.<span class="built_in">count</span>(n)) <span class="keyword">return</span> map_mu[n];</span><br><span class="line">    <span class="keyword">int</span> ans = (n &gt;= <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">2</span>, j; i &lt;= n; i = j + <span class="number">1</span>) &#123;</span><br><span class="line">        j = (n / (n / i));</span><br><span class="line">        ans -= <span class="built_in">sieveMu</span>(n / i) * (j - i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> map_mu[n] = ans; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">sievePhi</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; Limit) <span class="keyword">return</span> phi[n];</span><br><span class="line">    <span class="keyword">if</span> (map_phi.<span class="built_in">count</span>(n)) <span class="keyword">return</span> map_phi[n];</span><br><span class="line">    ll ans = <span class="number">1ll</span> * n * ((ll)(n) + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">2</span>, j; i &lt;= n; i = j + <span class="number">1</span>) &#123;</span><br><span class="line">        j = (n / (n / i));</span><br><span class="line">        ans -= <span class="number">1ll</span> * <span class="built_in">sievePhi</span>(n / i) * (j - i + <span class="number">1</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> map_phi[n] = ans; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Prime_Test</title>
      <link href="/2018/11/24/PrimeTest_/"/>
      <url>/2018/11/24/PrimeTest_/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="Quadratic-residue"><a href="#Quadratic-residue" class="headerlink" title="Quadratic residue"></a>Quadratic residue</h1><p>二次剩余</p><p><strong>定义：</strong></p><p>当存在某个$x$，式子$x^2\equiv d \pmod p$成立，称<strong>&quot;$x$是$d$是模$p$下的二次剩余&quot;</strong>。</p><p><strong>性质：</strong></p><ul><li>对于一个数$0 \sim p - 1$的数，因为$x^2 \equiv (p-x)^2$，所以关于$p$的二次剩余的不超过$\frac{p}{2}+1$个。</li><li>二次剩余成二次剩余也是二次剩余</li></ul><h1 id="Miller-Rabin"><a href="#Miller-Rabin" class="headerlink" title="Miller-Rabin"></a>Miller-Rabin</h1><p>考虑一种判断质数的方法，根据费马小定理，$a^{p-1} \equiv 1 \pmod p$。为了检测$p$是否为质数，可以带入几个数，判断费马小定理是否成立，如果都成立，那么可以认为这个数是质数。</p><p>但是有一些数没办法判断出来，如$561=3\times11\times17$，<strong>这一类数叫做Carmichael数（卡迈尔克数）。</strong>这一类数虽然不多，但是在$1e8$内还是有$255$个，会严重影响算法的正确率，Miller-Rabin这个算法便诞生了。</p><p>设要检测的数为$n$，$n$为奇数。</p>$$n=r\times 2^t + 1$$<p>根据$\text{Chinese Remainder Theorem}$，如果$n$是质数，$1$的在模$n$下二次剩余只有$1$和$n-1$。例如$6^2\equiv -1\pmod {37}$，$6^3 \equiv 1 \pmod {37}$，反之对于非质数会有更多其他的数，例如$11 \not \equiv -1$，$11^2 \equiv 1 \pmod {15}$，说明$15$是非质数。</p><p>对于<strong>不被$n$整除</strong>的一个数$A$，如果$n$为质数，根据费马小，有$A^{n-1} \equiv 1\to A^{r\times 2^t} \equiv 1\pmod n$。</p><p>考虑这个$1$是怎么来的，那么根据二次剩余，下面两个条件之一必然成立。</p><ul><li>$A^r \equiv1 \pmod n$</li><li>$\exists_{k=0}^{t-1}A^{r2^k} \equiv -1 \pmod n$</li></ul><p>于是我们检测到第一个$A^{r2^{k+1}}\equiv1$，那么$A^{r2^{k}} \equiv -1 \pmod n$。如果不是，则说明$n$不是质数。所以可以随机一个底数$A$，或者是取前几个小质数作为$A$。</p><p>对于一个奇合数$x$，它的证据个数有$\frac{x-1}{2}$个，对于一个证据，检测出的概率是$\frac{1}{2}$。如果选择了$n$个底数，那么正确的概率约为$2^{-n}$。</p><p>对于$1e18$的范围的数，取前12个质数就可以正确了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> pri[] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">21</span>, <span class="number">23</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">37</span>&#125;;</span><br><span class="line"><span class="function">IL <span class="keyword">bool</span> <span class="title">Miller_Rabin</span><span class="params">(ll n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i) <span class="keyword">if</span> (n % pri[i] == <span class="number">0</span>) <span class="keyword">return</span> n == pri[i];</span><br><span class="line">    ll r, x, y; <span class="keyword">int</span> t;</span><br><span class="line">    <span class="keyword">for</span> (r = n - <span class="number">1</span>, t = <span class="number">0</span>; ~r &amp; <span class="number">1</span>; r &gt;&gt;= <span class="number">1</span>, t++);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i) &#123;</span><br><span class="line">        x = <span class="built_in">fpw</span>(pri[i], r, n); </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; t &amp;&amp; x &gt; <span class="number">1</span>; ++j) &#123;</span><br><span class="line">            y = <span class="built_in">mul</span>(x, x, n);</span><br><span class="line">            <span class="keyword">if</span> (y == <span class="number">1</span> &amp;&amp; x != n - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">            x = y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x != <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Birthday-problem"><a href="#Birthday-problem" class="headerlink" title="Birthday problem"></a>Birthday problem</h1><p>生日悖论，23个人中两个人有相同生日的概率大于$50\%$。</p><p>对于<strong>值域为$P$</strong>，出现<strong>至少两个相同的数</strong>的概率为$1-\frac{P-1}{P}^{\binom{n}{2}}$</p><h1 id="Pollard’s-Rho"><a href="#Pollard’s-Rho" class="headerlink" title="Pollard’s Rho"></a>Pollard’s Rho</h1><p>对于一个非质数$n$，存在$a_1$和$a_2$使得$n=a_1\times a_2$，那么递归分解$a_1$和$a_2$就可以实现质因数分解。</p><p>假设$a_1$是$n$的因子，暴力地可以随机一个数然后判断是否为$a_1$，这样找到$a1$的概率为$\frac{1}{n}$实在太小。如果得到了两个数$x$和$y$，其中$x\equiv y \pmod {a_1}$且$x\not \equiv y \pmod n$。如果$gcd(x−y,n)$不为$1$或$n$，那么可以得到 $n$ 的一个非平凡因子。</p><p>往一个纸带上填数，值域为$P$，出现有两个数就停下（显然步数最大为$P+1$)，期望的长度是多少？一共存在$\binom{len}{len-1}$对数，而每队相等的概率为$\frac{1}{p}$</p>$$len\times (len-1)\times \frac{1}{P}=1\\len\approx\sqrt{P}$$<p>我们可以算出$len$的期望长度为$\sqrt P$，也就是在模$n$意义下的期望长度为$\sqrt n$。</p><p>对于一组$(x,y)$，$y\equiv x\pmod a$的概率为$O(\frac{1}{n})$，根据生日悖论，如果选出大于$\sqrt n$组数，其中有两个相等的概率大于$\frac{1}{2}$，而后会更加快速地递增。</p><p>如果我们每次合理的随机选择$x,y$，使得$x-y$不相等，在大小为$n$的集合中，选出合理的$(x,y)$概率为$\sqrt n$，因为集合大小为$\sqrt n$，那么找到相等的概率为$\sqrt {\sqrt n}$，也就说$O(n^{\frac{1}{4}})$。</p><p>我们构造一个随机的函数$f(x)$使得$f(x)$在$\text{mod p}$意义下几乎随机，不断将$x$变为$f(x)$，$x$就会变为一个随机的数，经过测试，<strong>当$f(x)=x^2+c$的时候很合适</strong>。经过若干步以后一定会走到<strong>一个定长的环</strong>中。最开始$x,y$设为随机数，在每一步的操作中把$x$变为$f(x)$，$y$变为$f(f(y))$，检查$gcd(y-x,n)$。这样$y$每次比$x$多走一步，经过环长步以后$x,y$会到达相同位置。</p><p>因为对于每一步都要求一遍$gcd$，那么复杂度为$O(n^\frac{1}{4}\log n)$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IL ll <span class="title">func</span><span class="params">(ll x, ll mod, ll a)</span> </span>&#123; <span class="keyword">return</span> (<span class="built_in">mul</span>(x, x, mod) + a) % mod; &#125;</span><br><span class="line"><span class="function">IL ll <span class="title">Find</span><span class="params">(ll n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> Test_Limit = <span class="number">150000</span>;</span><br><span class="line">    ll a = <span class="built_in">rand</span>(), x, y; <span class="keyword">int</span> tim = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">12</span>; ++i) <span class="keyword">if</span> (n % pri[i] == <span class="number">0</span>) <span class="keyword">return</span> pri[i];</span><br><span class="line">    x = <span class="built_in">func</span>(<span class="built_in">rand</span>(), n, a), y = x;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        ull g = <span class="built_in">gcd</span>((x - y + n) % n, n);</span><br><span class="line">        <span class="keyword">if</span> (g != <span class="number">1</span> &amp;&amp; g != n) <span class="keyword">return</span> g; </span><br><span class="line">        x = <span class="built_in">func</span>(x, n, a), y = <span class="built_in">func</span>(<span class="built_in">func</span>(y, n, a), n, a); ++tim; </span><br><span class="line">    &#125; <span class="keyword">while</span> (y != x &amp;&amp; tim &lt;= Test_Limit);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pollard_s_Rho</span><span class="params">(ll n, ll &amp;a)</span> </span>&#123;</span><br><span class="line">    ll d; <span class="keyword">if</span> (n &lt;= a) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">while</span> (!(n &amp; <span class="number">1</span>)) n &gt;&gt;= <span class="number">1</span>, a = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || <span class="built_in">Miller_Rabin</span>(n)) &#123; a = <span class="built_in">max</span>(a, n); <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="keyword">for</span> (d = <span class="built_in">Find</span>(n); d == <span class="number">-1</span>; d = <span class="built_in">Find</span>(n));</span><br><span class="line">    <span class="keyword">if</span> (d &gt; n / d) d = n / d; <span class="built_in">Pollard_s_Rho</span>(d, a); <span class="built_in">Pollard_s_Rho</span>(n / d, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Pollard’s-Rho-Update"><a href="#Pollard’s-Rho-Update" class="headerlink" title="Pollard’s Rho Update"></a>Pollard’s Rho Update</h1><p>但这并不是$\text{Pollard's Prho}$能达到的最优复杂度，可以优化为$O(n^\frac{1}{4})$。</p><p>首先$\gcd$的写法可以加上一点常数优化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IL ll <span class="title">gcd</span><span class="params">(ll x, ll y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Shift = <span class="built_in">ctzll</span>(x | y);</span><br><span class="line">    y &gt;&gt;= <span class="built_in">ctzll</span>(y);</span><br><span class="line">    <span class="keyword">while</span> (x) &#123;</span><br><span class="line">        x &gt;&gt;= <span class="built_in">ctzll</span>(x); </span><br><span class="line">        <span class="keyword">if</span> (x &lt; y) <span class="built_in">swap</span>(x, y);</span><br><span class="line">        x -= y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y &lt;&lt; Shift;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据奇偶性，每隔两次$x$至少要除$2$，而换成非递归会快一点。</p><p>我们可以注意到$\gcd(t,n) | gcd(tq,n)$， 设定一个步长$M$，固定$x$，$y$一共跳$M$步，把每一步的$y-x$相等然后取$gcd$。虽然还是遍历了$\sqrt n$个元素，但是每隔$M$次取一次gcd可以降低复杂度，使得它为$O(\frac{n^{\frac{1}{4}}}{M}\times \log n)$。</p><p><a href="/images/PR/PR.png" class="gallery-item"><img src="/images/PR/PR.png" alt=""></a></p><p>如上图所示，图中的$Y$将从$X$跳到$2^{l+1}$的位置，因为之前<strong>已经算过蓝色部分并没有得到结果</strong>，那么因为图中的<strong>红色部分和蓝色部分等长，重复算红色部分没有意义</strong>，$Y$可以直接跳到现在这个位置；$Y$现在从图中$Y$的位置开始，每次跳$M$步，把每一步的$y-x$乘起来然后和$n$取$\gcd$检验。同样的，如果不是$1$或者是$n$说明找到了直接return；如果是$1$，视为没有找到；如果是$n$，可能这个$n$是由前面的几个数相乘得到的，也可能是走完了一个环，此时$x=y,gcd(y-x,n)=n$，那么我们需要再走一遍$M$这么长，判断中间是否出现结果，找到答案然后返回。</p><p> 具体实现看代码（unsigned long long和__uint128_t真快)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ctzll __builtin_ctzll</span></span><br><span class="line"><span class="keyword">namespace</span> Rho &#123;</span><br><span class="line">    <span class="function">IL ll <span class="title">gcd</span><span class="params">(ll x, ll y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> Shift = <span class="built_in">ctzll</span>(x | y);</span><br><span class="line">        y &gt;&gt;= <span class="built_in">ctzll</span>(y);</span><br><span class="line">        <span class="keyword">while</span> (x) &#123;</span><br><span class="line">            x &gt;&gt;= <span class="built_in">ctzll</span>(x);</span><br><span class="line">            <span class="keyword">if</span> (x &lt; y) <span class="built_in">swap</span>(x, y);</span><br><span class="line">            x -= y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> y &lt;&lt; Shift;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">IL ll <span class="title">func</span><span class="params">(ll x, ll Mod, ll c)</span> </span>&#123; <span class="keyword">return</span> (<span class="built_in">mul</span>(x, x, Mod) + c) % Mod; &#125;</span><br><span class="line">    <span class="function">IL ll <span class="title">Find</span><span class="params">(ll n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> Step = <span class="number">1</span> &lt;&lt; <span class="number">9</span>; <span class="keyword">int</span> c = <span class="built_in">rand</span>();</span><br><span class="line">        ll x, y, temp; x = y = <span class="built_in">rand</span>() % n; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; ; l &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            x = y; </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; ++i) y = <span class="built_in">func</span>(y, n, c);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; l; k += Step) &#123;</span><br><span class="line">                ll Prod_g = <span class="number">1</span>;</span><br><span class="line">                temp = y;</span><br><span class="line">                <span class="keyword">int</span> rem = <span class="built_in">min</span>(l - k, Step);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rem; ++i) y = <span class="built_in">func</span>(y, n, c), Prod_g = <span class="built_in">mul</span>(Prod_g, (y + n - x) % n, n);</span><br><span class="line">                Prod_g = <span class="built_in">gcd</span>(Prod_g, n);</span><br><span class="line">                <span class="keyword">if</span> (Prod_g == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (Prod_g == n) <span class="keyword">for</span> (y = temp, Prod_g = <span class="number">1</span>; Prod_g == <span class="number">1</span>; ) y = <span class="built_in">func</span>(y, n, c), Prod_g = <span class="built_in">gcd</span>(y + n - x, n); </span><br><span class="line">                <span class="keyword">return</span> Prod_g;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;           </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function">IL <span class="keyword">void</span> <span class="title">Pollard_s_Rho</span><span class="params">(ll n)</span> </span>&#123;&#125; <span class="comment">// 同上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
